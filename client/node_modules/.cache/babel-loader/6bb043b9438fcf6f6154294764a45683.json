{"ast":null,"code":"/* eslint-disable no-continue */\nimport { nanoid } from 'nanoid';\nimport { CUSTOM_MESSAGE_TYPE } from '../../constants/messageTypes';\nimport { isDate } from '../../context/TranslationContext';\n/**\n * processMessages - Transform the input message list according to config parameters\n *\n * Inserts date separators btw. messages created on different dates or before unread incoming messages. By default:\n * - enabled in main message list\n * - disabled in virtualized message list\n * - disabled in thread\n *\n * Allows to filter out deleted messages, contolled by hideDeletedMessages param. This is disabled by default.\n *\n * Sets Giphy preview message for VirtualizedMessageList\n *\n * The only required params are messages and userId, the rest are config params:\n *\n * @return {StreamMessage<StreamChatGenerics>[]} Transformed list of messages\n */\n\nexport var processMessages = function (params) {\n  var _a, _b;\n\n  var enableDateSeparator = params.enableDateSeparator,\n      hideDeletedMessages = params.hideDeletedMessages,\n      hideNewMessageSeparator = params.hideNewMessageSeparator,\n      lastRead = params.lastRead,\n      messages = params.messages,\n      setGiphyPreviewMessage = params.setGiphyPreviewMessage,\n      userId = params.userId;\n  var unread = false;\n  var ephemeralMessagePresent = false;\n  var lastDateSeparator;\n  var newMessages = [];\n\n  for (var i = 0; i < messages.length; i += 1) {\n    var message = messages[i];\n\n    if (hideDeletedMessages && message.type === 'deleted') {\n      continue;\n    }\n\n    if (setGiphyPreviewMessage && message.type === 'ephemeral' && message.command === 'giphy') {\n      ephemeralMessagePresent = true;\n      setGiphyPreviewMessage(message);\n      continue;\n    }\n\n    var messageDate = message.created_at && isDate(message.created_at) && message.created_at.toDateString() || '';\n    var previousMessage = messages[i - 1];\n    var prevMessageDate = messageDate;\n\n    if (enableDateSeparator && (previousMessage === null || previousMessage === void 0 ? void 0 : previousMessage.created_at) && isDate(previousMessage.created_at)) {\n      prevMessageDate = previousMessage.created_at.toDateString();\n    }\n\n    if (!unread && !hideNewMessageSeparator) {\n      unread = lastRead && message.created_at && new Date(lastRead) < message.created_at || false; // do not show date separator for current user's messages\n\n      if (enableDateSeparator && unread && ((_a = message.user) === null || _a === void 0 ? void 0 : _a.id) !== userId) {\n        newMessages.push({\n          customType: CUSTOM_MESSAGE_TYPE.date,\n          date: message.created_at,\n          id: makeDateMessageId(message.created_at),\n          unread: unread\n        });\n      }\n    }\n\n    if (enableDateSeparator && (i === 0 || // always put date separator before the first message\n    messageDate !== prevMessageDate || // add date separator btw. 2 messages created on different date\n    // if hiding deleted messages replace the previous deleted message(s) with A separator if the last rendered message was created on different date\n    hideDeletedMessages && (previousMessage === null || previousMessage === void 0 ? void 0 : previousMessage.type) === 'deleted' && lastDateSeparator !== messageDate) && ((_b = newMessages === null || newMessages === void 0 ? void 0 : newMessages[newMessages.length - 1]) === null || _b === void 0 ? void 0 : _b.customType) !== CUSTOM_MESSAGE_TYPE.date // do not show two date separators in a row)\n    ) {\n      lastDateSeparator = messageDate;\n      newMessages.push({\n        customType: CUSTOM_MESSAGE_TYPE.date,\n        date: message.created_at,\n        id: makeDateMessageId(message.created_at)\n      }, message);\n    } else {\n      newMessages.push(message);\n    }\n  } // clean up the giphy preview component state after a Cancel action\n\n\n  if (setGiphyPreviewMessage && !ephemeralMessagePresent) {\n    setGiphyPreviewMessage(undefined);\n  }\n\n  return newMessages;\n};\nexport var makeDateMessageId = function (date) {\n  var idSuffix;\n\n  try {\n    idSuffix = !date ? nanoid() : date instanceof Date ? date.toISOString() : date;\n  } catch (e) {\n    idSuffix = nanoid();\n  }\n\n  return \"\".concat(CUSTOM_MESSAGE_TYPE.date, \"-\").concat(idSuffix);\n}; // fast since it usually iterates just the last few messages\n\nexport var getLastReceived = function (messages) {\n  for (var i = messages.length - 1; i > 0; i -= 1) {\n    if (messages[i].status === 'received') {\n      return messages[i].id;\n    }\n  }\n\n  return null;\n};\nexport var getReadStates = function (messages, read, returnAllReadData) {\n  if (read === void 0) {\n    read = {};\n  } // create object with empty array for each message id\n\n\n  var readData = {};\n  Object.values(read).forEach(function (readState) {\n    if (!readState.last_read) return;\n    var userLastReadMsgId; // loop messages sent by current user and add read data for other users in channel\n\n    messages.forEach(function (msg) {\n      if (msg.updated_at && msg.updated_at < readState.last_read) {\n        userLastReadMsgId = msg.id; // if true, save other user's read data for all messages they've read\n\n        if (returnAllReadData) {\n          if (!readData[userLastReadMsgId]) {\n            readData[userLastReadMsgId] = [];\n          }\n\n          readData[userLastReadMsgId].push(readState.user);\n        }\n      }\n    }); // if true, only save read data for other user's last read message\n\n    if (userLastReadMsgId && !returnAllReadData) {\n      if (!readData[userLastReadMsgId]) {\n        readData[userLastReadMsgId] = [];\n      }\n\n      readData[userLastReadMsgId].push(readState.user);\n    }\n  });\n  return readData;\n};\nexport var insertIntro = function (messages, headerPosition) {\n  var newMessages = messages;\n  var intro = {\n    customType: CUSTOM_MESSAGE_TYPE.intro\n  }; // if no headerPosition is set, HeaderComponent will go at the top\n\n  if (!headerPosition) {\n    newMessages.unshift(intro);\n    return newMessages;\n  } // if no messages, intro gets inserted\n\n\n  if (!newMessages.length) {\n    newMessages.unshift(intro);\n    return newMessages;\n  } // else loop over the messages\n\n\n  for (var i = 0; i < messages.length; i += 1) {\n    var message = messages[i];\n    var messageTime = message.created_at && isDate(message.created_at) ? message.created_at.getTime() : null;\n    var nextMessage = messages[i + 1];\n    var nextMessageTime = nextMessage.created_at && isDate(nextMessage.created_at) ? nextMessage.created_at.getTime() : null; // header position is smaller than message time so comes after;\n\n    if (messageTime && messageTime < headerPosition) {\n      // if header position is also smaller than message time continue;\n      if (nextMessageTime && nextMessageTime < headerPosition) {\n        if (messages[i + 1] && messages[i + 1].customType === CUSTOM_MESSAGE_TYPE.date) continue;\n\n        if (!nextMessageTime) {\n          newMessages.push(intro);\n          return newMessages;\n        }\n      } else {\n        newMessages.splice(i + 1, 0, intro);\n        return newMessages;\n      }\n    }\n  }\n\n  return newMessages;\n};\nexport var getGroupStyles = function (message, previousMessage, nextMessage, noGroupByUser) {\n  var _a, _b, _c, _d, _e, _f, _g;\n\n  if (message.customType === CUSTOM_MESSAGE_TYPE.date) return '';\n  if (message.customType === CUSTOM_MESSAGE_TYPE.intro) return '';\n  if (noGroupByUser || ((_a = message.attachments) === null || _a === void 0 ? void 0 : _a.length) !== 0) return 'single';\n  var isTopMessage = !previousMessage || previousMessage.customType === CUSTOM_MESSAGE_TYPE.intro || previousMessage.customType === CUSTOM_MESSAGE_TYPE.date || previousMessage.type === 'system' || ((_b = previousMessage.attachments) === null || _b === void 0 ? void 0 : _b.length) !== 0 || ((_c = message.user) === null || _c === void 0 ? void 0 : _c.id) !== ((_d = previousMessage.user) === null || _d === void 0 ? void 0 : _d.id) || previousMessage.type === 'error' || previousMessage.deleted_at || message.reaction_counts && Object.keys(message.reaction_counts).length > 0;\n  var isBottomMessage = !nextMessage || nextMessage.customType === CUSTOM_MESSAGE_TYPE.date || nextMessage.type === 'system' || nextMessage.customType === CUSTOM_MESSAGE_TYPE.intro || ((_e = nextMessage.attachments) === null || _e === void 0 ? void 0 : _e.length) !== 0 || ((_f = message.user) === null || _f === void 0 ? void 0 : _f.id) !== ((_g = nextMessage.user) === null || _g === void 0 ? void 0 : _g.id) || nextMessage.type === 'error' || nextMessage.deleted_at || nextMessage.reaction_counts && Object.keys(nextMessage.reaction_counts).length > 0;\n\n  if (!isTopMessage && !isBottomMessage) {\n    if (message.deleted_at || message.type === 'error') return 'single';\n    return 'middle';\n  }\n\n  if (isBottomMessage) {\n    if (isTopMessage || message.deleted_at || message.type === 'error') return 'single';\n    return 'bottom';\n  }\n\n  if (isTopMessage) return 'top';\n  return '';\n}; // \"Probably\" included, because it may happen that the last page was returned and it has exactly the size of the limit\n// but the back-end cannot provide us with information on whether it has still more messages in the DB\n// FIXME: once the pagination state is moved from Channel to MessageList, these should be moved as well.\n//  The MessageList should have configurable the limit for performing the requests.\n//  This parameter would then be used within these functions\n\nexport var hasMoreMessagesProbably = function (returnedCountMessages, limit) {\n  return returnedCountMessages === limit;\n};\nexport var hasNotMoreMessages = function (returnedCountMessages, limit) {\n  return returnedCountMessages < limit;\n};","map":{"version":3,"names":["nanoid","CUSTOM_MESSAGE_TYPE","isDate","processMessages","params","_a","_b","enableDateSeparator","hideDeletedMessages","hideNewMessageSeparator","lastRead","messages","setGiphyPreviewMessage","userId","unread","ephemeralMessagePresent","lastDateSeparator","newMessages","i","length","message","type","command","messageDate","created_at","toDateString","previousMessage","prevMessageDate","Date","user","id","push","customType","date","makeDateMessageId","undefined","idSuffix","toISOString","e","concat","getLastReceived","status","getReadStates","read","returnAllReadData","readData","Object","values","forEach","readState","last_read","userLastReadMsgId","msg","updated_at","insertIntro","headerPosition","intro","unshift","messageTime","getTime","nextMessage","nextMessageTime","splice","getGroupStyles","noGroupByUser","_c","_d","_e","_f","_g","attachments","isTopMessage","deleted_at","reaction_counts","keys","isBottomMessage","hasMoreMessagesProbably","returnedCountMessages","limit","hasNotMoreMessages"],"sources":["/home/betty/web-app-practice/memory-game/client/node_modules/stream-chat-react/dist/components/MessageList/utils.js"],"sourcesContent":["/* eslint-disable no-continue */\nimport { nanoid } from 'nanoid';\nimport { CUSTOM_MESSAGE_TYPE } from '../../constants/messageTypes';\nimport { isDate } from '../../context/TranslationContext';\n/**\n * processMessages - Transform the input message list according to config parameters\n *\n * Inserts date separators btw. messages created on different dates or before unread incoming messages. By default:\n * - enabled in main message list\n * - disabled in virtualized message list\n * - disabled in thread\n *\n * Allows to filter out deleted messages, contolled by hideDeletedMessages param. This is disabled by default.\n *\n * Sets Giphy preview message for VirtualizedMessageList\n *\n * The only required params are messages and userId, the rest are config params:\n *\n * @return {StreamMessage<StreamChatGenerics>[]} Transformed list of messages\n */\nexport var processMessages = function (params) {\n    var _a, _b;\n    var enableDateSeparator = params.enableDateSeparator, hideDeletedMessages = params.hideDeletedMessages, hideNewMessageSeparator = params.hideNewMessageSeparator, lastRead = params.lastRead, messages = params.messages, setGiphyPreviewMessage = params.setGiphyPreviewMessage, userId = params.userId;\n    var unread = false;\n    var ephemeralMessagePresent = false;\n    var lastDateSeparator;\n    var newMessages = [];\n    for (var i = 0; i < messages.length; i += 1) {\n        var message = messages[i];\n        if (hideDeletedMessages && message.type === 'deleted') {\n            continue;\n        }\n        if (setGiphyPreviewMessage && message.type === 'ephemeral' && message.command === 'giphy') {\n            ephemeralMessagePresent = true;\n            setGiphyPreviewMessage(message);\n            continue;\n        }\n        var messageDate = (message.created_at && isDate(message.created_at) && message.created_at.toDateString()) || '';\n        var previousMessage = messages[i - 1];\n        var prevMessageDate = messageDate;\n        if (enableDateSeparator && (previousMessage === null || previousMessage === void 0 ? void 0 : previousMessage.created_at) && isDate(previousMessage.created_at)) {\n            prevMessageDate = previousMessage.created_at.toDateString();\n        }\n        if (!unread && !hideNewMessageSeparator) {\n            unread = (lastRead && message.created_at && new Date(lastRead) < message.created_at) || false;\n            // do not show date separator for current user's messages\n            if (enableDateSeparator && unread && ((_a = message.user) === null || _a === void 0 ? void 0 : _a.id) !== userId) {\n                newMessages.push({\n                    customType: CUSTOM_MESSAGE_TYPE.date,\n                    date: message.created_at,\n                    id: makeDateMessageId(message.created_at),\n                    unread: unread,\n                });\n            }\n        }\n        if (enableDateSeparator &&\n            (i === 0 || // always put date separator before the first message\n                messageDate !== prevMessageDate || // add date separator btw. 2 messages created on different date\n                // if hiding deleted messages replace the previous deleted message(s) with A separator if the last rendered message was created on different date\n                (hideDeletedMessages &&\n                    (previousMessage === null || previousMessage === void 0 ? void 0 : previousMessage.type) === 'deleted' &&\n                    lastDateSeparator !== messageDate)) &&\n            ((_b = newMessages === null || newMessages === void 0 ? void 0 : newMessages[newMessages.length - 1]) === null || _b === void 0 ? void 0 : _b.customType) !== CUSTOM_MESSAGE_TYPE.date // do not show two date separators in a row)\n        ) {\n            lastDateSeparator = messageDate;\n            newMessages.push({\n                customType: CUSTOM_MESSAGE_TYPE.date,\n                date: message.created_at,\n                id: makeDateMessageId(message.created_at),\n            }, message);\n        }\n        else {\n            newMessages.push(message);\n        }\n    }\n    // clean up the giphy preview component state after a Cancel action\n    if (setGiphyPreviewMessage && !ephemeralMessagePresent) {\n        setGiphyPreviewMessage(undefined);\n    }\n    return newMessages;\n};\nexport var makeDateMessageId = function (date) {\n    var idSuffix;\n    try {\n        idSuffix = !date ? nanoid() : date instanceof Date ? date.toISOString() : date;\n    }\n    catch (e) {\n        idSuffix = nanoid();\n    }\n    return \"\".concat(CUSTOM_MESSAGE_TYPE.date, \"-\").concat(idSuffix);\n};\n// fast since it usually iterates just the last few messages\nexport var getLastReceived = function (messages) {\n    for (var i = messages.length - 1; i > 0; i -= 1) {\n        if (messages[i].status === 'received') {\n            return messages[i].id;\n        }\n    }\n    return null;\n};\nexport var getReadStates = function (messages, read, returnAllReadData) {\n    if (read === void 0) { read = {}; }\n    // create object with empty array for each message id\n    var readData = {};\n    Object.values(read).forEach(function (readState) {\n        if (!readState.last_read)\n            return;\n        var userLastReadMsgId;\n        // loop messages sent by current user and add read data for other users in channel\n        messages.forEach(function (msg) {\n            if (msg.updated_at && msg.updated_at < readState.last_read) {\n                userLastReadMsgId = msg.id;\n                // if true, save other user's read data for all messages they've read\n                if (returnAllReadData) {\n                    if (!readData[userLastReadMsgId]) {\n                        readData[userLastReadMsgId] = [];\n                    }\n                    readData[userLastReadMsgId].push(readState.user);\n                }\n            }\n        });\n        // if true, only save read data for other user's last read message\n        if (userLastReadMsgId && !returnAllReadData) {\n            if (!readData[userLastReadMsgId]) {\n                readData[userLastReadMsgId] = [];\n            }\n            readData[userLastReadMsgId].push(readState.user);\n        }\n    });\n    return readData;\n};\nexport var insertIntro = function (messages, headerPosition) {\n    var newMessages = messages;\n    var intro = {\n        customType: CUSTOM_MESSAGE_TYPE.intro,\n    };\n    // if no headerPosition is set, HeaderComponent will go at the top\n    if (!headerPosition) {\n        newMessages.unshift(intro);\n        return newMessages;\n    }\n    // if no messages, intro gets inserted\n    if (!newMessages.length) {\n        newMessages.unshift(intro);\n        return newMessages;\n    }\n    // else loop over the messages\n    for (var i = 0; i < messages.length; i += 1) {\n        var message = messages[i];\n        var messageTime = message.created_at && isDate(message.created_at) ? message.created_at.getTime() : null;\n        var nextMessage = messages[i + 1];\n        var nextMessageTime = nextMessage.created_at && isDate(nextMessage.created_at)\n            ? nextMessage.created_at.getTime()\n            : null;\n        // header position is smaller than message time so comes after;\n        if (messageTime && messageTime < headerPosition) {\n            // if header position is also smaller than message time continue;\n            if (nextMessageTime && nextMessageTime < headerPosition) {\n                if (messages[i + 1] && messages[i + 1].customType === CUSTOM_MESSAGE_TYPE.date)\n                    continue;\n                if (!nextMessageTime) {\n                    newMessages.push(intro);\n                    return newMessages;\n                }\n            }\n            else {\n                newMessages.splice(i + 1, 0, intro);\n                return newMessages;\n            }\n        }\n    }\n    return newMessages;\n};\nexport var getGroupStyles = function (message, previousMessage, nextMessage, noGroupByUser) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    if (message.customType === CUSTOM_MESSAGE_TYPE.date)\n        return '';\n    if (message.customType === CUSTOM_MESSAGE_TYPE.intro)\n        return '';\n    if (noGroupByUser || ((_a = message.attachments) === null || _a === void 0 ? void 0 : _a.length) !== 0)\n        return 'single';\n    var isTopMessage = !previousMessage ||\n        previousMessage.customType === CUSTOM_MESSAGE_TYPE.intro ||\n        previousMessage.customType === CUSTOM_MESSAGE_TYPE.date ||\n        previousMessage.type === 'system' ||\n        ((_b = previousMessage.attachments) === null || _b === void 0 ? void 0 : _b.length) !== 0 ||\n        ((_c = message.user) === null || _c === void 0 ? void 0 : _c.id) !== ((_d = previousMessage.user) === null || _d === void 0 ? void 0 : _d.id) ||\n        previousMessage.type === 'error' ||\n        previousMessage.deleted_at ||\n        (message.reaction_counts && Object.keys(message.reaction_counts).length > 0);\n    var isBottomMessage = !nextMessage ||\n        nextMessage.customType === CUSTOM_MESSAGE_TYPE.date ||\n        nextMessage.type === 'system' ||\n        nextMessage.customType === CUSTOM_MESSAGE_TYPE.intro ||\n        ((_e = nextMessage.attachments) === null || _e === void 0 ? void 0 : _e.length) !== 0 ||\n        ((_f = message.user) === null || _f === void 0 ? void 0 : _f.id) !== ((_g = nextMessage.user) === null || _g === void 0 ? void 0 : _g.id) ||\n        nextMessage.type === 'error' ||\n        nextMessage.deleted_at ||\n        (nextMessage.reaction_counts && Object.keys(nextMessage.reaction_counts).length > 0);\n    if (!isTopMessage && !isBottomMessage) {\n        if (message.deleted_at || message.type === 'error')\n            return 'single';\n        return 'middle';\n    }\n    if (isBottomMessage) {\n        if (isTopMessage || message.deleted_at || message.type === 'error')\n            return 'single';\n        return 'bottom';\n    }\n    if (isTopMessage)\n        return 'top';\n    return '';\n};\n// \"Probably\" included, because it may happen that the last page was returned and it has exactly the size of the limit\n// but the back-end cannot provide us with information on whether it has still more messages in the DB\n// FIXME: once the pagination state is moved from Channel to MessageList, these should be moved as well.\n//  The MessageList should have configurable the limit for performing the requests.\n//  This parameter would then be used within these functions\nexport var hasMoreMessagesProbably = function (returnedCountMessages, limit) {\n    return returnedCountMessages === limit;\n};\nexport var hasNotMoreMessages = function (returnedCountMessages, limit) {\n    return returnedCountMessages < limit;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}