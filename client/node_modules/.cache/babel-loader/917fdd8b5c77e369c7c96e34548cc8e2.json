{"ast":null,"code":"import { useMemo, useRef } from 'react';\nexport function usePrependedMessagesCount(messages, hasDateSeparator) {\n  var firstRealMessageIndex = hasDateSeparator ? 1 : 0;\n  var firstMessageId = useRef();\n  var earliestMessageId = useRef();\n  var previousNumItemsPrepended = useRef(0);\n  var numItemsPrepended = useMemo(function () {\n    var _a;\n\n    if (!messages || !messages.length) {\n      previousNumItemsPrepended.current = 0;\n      return 0;\n    }\n\n    var currentFirstMessageId = (_a = messages === null || messages === void 0 ? void 0 : messages[firstRealMessageIndex]) === null || _a === void 0 ? void 0 : _a.id; // if no new messages were prepended, return early (same amount as before)\n\n    if (currentFirstMessageId === earliestMessageId.current) {\n      return previousNumItemsPrepended.current;\n    }\n\n    if (!firstMessageId.current) {\n      firstMessageId.current = currentFirstMessageId;\n    }\n\n    earliestMessageId.current = currentFirstMessageId; // if new messages were prepended, find out how many\n    // start with this number because there cannot be fewer prepended items than before\n\n    for (var i = previousNumItemsPrepended.current; i < messages.length; i += 1) {\n      if (messages[i].id === firstMessageId.current) {\n        previousNumItemsPrepended.current = i;\n        return i;\n      }\n    } // if no match has found, we have jumped - reset the prepend item count.\n\n\n    firstMessageId.current = currentFirstMessageId;\n    previousNumItemsPrepended.current = 0;\n    return 0; // TODO: there's a bug here, the messages prop is the same array instance (something mutates it)\n    // that's why the second dependency is necessary\n  }, [messages, messages === null || messages === void 0 ? void 0 : messages.length]);\n  return numItemsPrepended;\n}","map":{"version":3,"names":["useMemo","useRef","usePrependedMessagesCount","messages","hasDateSeparator","firstRealMessageIndex","firstMessageId","earliestMessageId","previousNumItemsPrepended","numItemsPrepended","_a","length","current","currentFirstMessageId","id","i"],"sources":["/home/betty/web-app-practice/memory-game/client/node_modules/stream-chat-react/dist/components/MessageList/hooks/usePrependMessagesCount.js"],"sourcesContent":["import { useMemo, useRef } from 'react';\nexport function usePrependedMessagesCount(messages, hasDateSeparator) {\n    var firstRealMessageIndex = hasDateSeparator ? 1 : 0;\n    var firstMessageId = useRef();\n    var earliestMessageId = useRef();\n    var previousNumItemsPrepended = useRef(0);\n    var numItemsPrepended = useMemo(function () {\n        var _a;\n        if (!messages || !messages.length) {\n            previousNumItemsPrepended.current = 0;\n            return 0;\n        }\n        var currentFirstMessageId = (_a = messages === null || messages === void 0 ? void 0 : messages[firstRealMessageIndex]) === null || _a === void 0 ? void 0 : _a.id;\n        // if no new messages were prepended, return early (same amount as before)\n        if (currentFirstMessageId === earliestMessageId.current) {\n            return previousNumItemsPrepended.current;\n        }\n        if (!firstMessageId.current) {\n            firstMessageId.current = currentFirstMessageId;\n        }\n        earliestMessageId.current = currentFirstMessageId;\n        // if new messages were prepended, find out how many\n        // start with this number because there cannot be fewer prepended items than before\n        for (var i = previousNumItemsPrepended.current; i < messages.length; i += 1) {\n            if (messages[i].id === firstMessageId.current) {\n                previousNumItemsPrepended.current = i;\n                return i;\n            }\n        }\n        // if no match has found, we have jumped - reset the prepend item count.\n        firstMessageId.current = currentFirstMessageId;\n        previousNumItemsPrepended.current = 0;\n        return 0;\n        // TODO: there's a bug here, the messages prop is the same array instance (something mutates it)\n        // that's why the second dependency is necessary\n    }, [messages, messages === null || messages === void 0 ? void 0 : messages.length]);\n    return numItemsPrepended;\n}\n"],"mappings":"AAAA,SAASA,OAAT,EAAkBC,MAAlB,QAAgC,OAAhC;AACA,OAAO,SAASC,yBAAT,CAAmCC,QAAnC,EAA6CC,gBAA7C,EAA+D;EAClE,IAAIC,qBAAqB,GAAGD,gBAAgB,GAAG,CAAH,GAAO,CAAnD;EACA,IAAIE,cAAc,GAAGL,MAAM,EAA3B;EACA,IAAIM,iBAAiB,GAAGN,MAAM,EAA9B;EACA,IAAIO,yBAAyB,GAAGP,MAAM,CAAC,CAAD,CAAtC;EACA,IAAIQ,iBAAiB,GAAGT,OAAO,CAAC,YAAY;IACxC,IAAIU,EAAJ;;IACA,IAAI,CAACP,QAAD,IAAa,CAACA,QAAQ,CAACQ,MAA3B,EAAmC;MAC/BH,yBAAyB,CAACI,OAA1B,GAAoC,CAApC;MACA,OAAO,CAAP;IACH;;IACD,IAAIC,qBAAqB,GAAG,CAACH,EAAE,GAAGP,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAACE,qBAAD,CAAlE,MAA+F,IAA/F,IAAuGK,EAAE,KAAK,KAAK,CAAnH,GAAuH,KAAK,CAA5H,GAAgIA,EAAE,CAACI,EAA/J,CANwC,CAOxC;;IACA,IAAID,qBAAqB,KAAKN,iBAAiB,CAACK,OAAhD,EAAyD;MACrD,OAAOJ,yBAAyB,CAACI,OAAjC;IACH;;IACD,IAAI,CAACN,cAAc,CAACM,OAApB,EAA6B;MACzBN,cAAc,CAACM,OAAf,GAAyBC,qBAAzB;IACH;;IACDN,iBAAiB,CAACK,OAAlB,GAA4BC,qBAA5B,CAdwC,CAexC;IACA;;IACA,KAAK,IAAIE,CAAC,GAAGP,yBAAyB,CAACI,OAAvC,EAAgDG,CAAC,GAAGZ,QAAQ,CAACQ,MAA7D,EAAqEI,CAAC,IAAI,CAA1E,EAA6E;MACzE,IAAIZ,QAAQ,CAACY,CAAD,CAAR,CAAYD,EAAZ,KAAmBR,cAAc,CAACM,OAAtC,EAA+C;QAC3CJ,yBAAyB,CAACI,OAA1B,GAAoCG,CAApC;QACA,OAAOA,CAAP;MACH;IACJ,CAtBuC,CAuBxC;;;IACAT,cAAc,CAACM,OAAf,GAAyBC,qBAAzB;IACAL,yBAAyB,CAACI,OAA1B,GAAoC,CAApC;IACA,OAAO,CAAP,CA1BwC,CA2BxC;IACA;EACH,CA7B8B,EA6B5B,CAACT,QAAD,EAAWA,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAACQ,MAAxE,CA7B4B,CAA/B;EA8BA,OAAOF,iBAAP;AACH"},"metadata":{},"sourceType":"module"}